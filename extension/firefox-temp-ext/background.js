import{H as h}from"./assets/HistoryStore-D4jEreiL.js";const w={apiEndpoint:"https://api.chroniclesync.xyz",pagesUrl:"https://chroniclesync.pages.dev",clientId:"extension-default"},x="https://api-staging.chroniclesync.xyz";async function E(){try{const r=await chrome.storage.sync.get(["apiEndpoint","pagesUrl","clientId","environment","customApiUrl"]);let c=w.apiEndpoint;return r.environment==="staging"?c=x:r.environment==="custom"&&r.customApiUrl&&(c=r.customApiUrl),{apiEndpoint:c,pagesUrl:r.pagesUrl||w.pagesUrl,clientId:r.clientId||w.clientId}}catch(r){return console.error("Error loading config:",r),w}}async function z(){const r=await chrome.storage.local.get(["deviceId"]);if(r.deviceId)return r.deviceId;const c="device_"+Math.random().toString(36).substring(2);return await chrome.storage.local.set({deviceId:c}),c}async function M(){var e;const r=navigator.platform,c=navigator.userAgent,i=await z(),n="Chrome",t=((e=/Chrome\/([0-9.]+)/.exec(c))==null?void 0:e[1])||"unknown";return{deviceId:i,platform:r,userAgent:c,browserName:n,browserVersion:t}}const T=5*60*1e3;async function S(){try{return await chrome.storage.local.get(["initialized"]),await E(),await chrome.storage.local.set({initialized:!0}),!0}catch(r){return console.error("Failed to initialize extension:",r),!1}}async function f(r=!1){var c,i;try{if(!(await chrome.storage.local.get(["initialized"])).initialized&&!await S()){console.debug("Sync skipped: Extension not initialized");return}const t=await E();if(!t.clientId||t.clientId==="extension-default")throw console.debug("Sync paused: No client ID configured"),new Error("Please configure your Client ID in the extension popup");console.debug("Starting sync with client ID:",t.clientId);const e=await M(),s=Date.now(),a=(await chrome.storage.local.get(["lastSync"])).lastSync||0,p=r?0:a,y=new h;await y.init(),await y.updateDevice(e);const v=await chrome.history.search({text:"",startTime:p,endTime:s,maxResults:1e4}),D=(await Promise.all(v.map(async l=>l.url?(await chrome.history.getVisits({url:l.url})).filter(d=>{const u=d.visitTime||0;return u>=p&&u<=s}).map(d=>{var u;return{url:l.url,title:l.title||"",visitTime:d.visitTime||Date.now(),visitId:d.visitId.toString(),referringVisitId:((u=d.referringVisitId)==null?void 0:u.toString())||"0",transition:d.transition||"link",...e}}):[]))).flat();for(const l of D)await y.addEntry(l);const m=await y.getUnsyncedEntries();if(m.length>0){const l=await fetch(`${t.apiEndpoint}?clientId=${encodeURIComponent(t.clientId)}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({history:m,deviceInfo:e,lastSync:a})});if(!l.ok)throw new Error(`HTTP error! status: ${l.status}`);const g=await l.json();if(g.history&&g.history.length>0&&await y.mergeRemoteEntries(g.history),g.devices)for(const I of g.devices)await y.updateDevice(I);for(const I of m)await y.markAsSynced(I.visitId);const d=g.lastSyncTime||s,u=new Date(d).toLocaleString();await chrome.storage.local.set({lastSync:d}),await chrome.storage.sync.set({lastSync:u});try{chrome.runtime.sendMessage({type:"syncComplete",stats:{sent:m.length,received:((c=g.history)==null?void 0:c.length)||0,devices:((i=g.devices)==null?void 0:i.length)||0}}).catch(()=>{})}catch{}}console.debug("Successfully completed sync")}catch(n){console.error("Error syncing history:",n);try{const t=n instanceof Error?n.message:String(n);chrome.runtime.sendMessage({type:"syncError",error:t}).catch(()=>{})}catch{}}}f(!0);setInterval(()=>f(!1),T);chrome.tabs.onUpdated.addListener(async(r,c,i)=>{c.url&&(console.debug(`Navigation to: ${c.url}`),setTimeout(()=>f(!1),1e3))});chrome.runtime.onMessage.addListener((r,c,i)=>{if(r.type==="getClientId")return chrome.storage.local.get(["initialized"]).then(async n=>{if(!n.initialized&&!await S()){i({error:"Extension not initialized"});return}try{const t=await E();i({clientId:t.clientId==="extension-default"?null:t.clientId})}catch(t){const e=t instanceof Error?t.message:String(t);console.error("Error getting client ID:",e),i({error:"Failed to get client ID"})}}),!0;if(r.type==="triggerSync")return f(!0).then(()=>{i({success:!0,message:"Sync successful"})}).catch(n=>{const t=n instanceof Error?n.message:String(n);console.error("Manual sync failed:",t),i({error:t})}),!0;if(r.type==="getHistory"){const{deviceId:n,since:t,limit:e}=r,s=new h;return s.init().then(async()=>{try{const o=await s.getEntries(n,t),a=e?o.slice(0,e):o;i(a)}catch(o){const a=o instanceof Error?o.message:String(o);console.error("Error fetching history from IndexedDB:",a),i({error:a})}}).catch(o=>{const a=o instanceof Error?o.message:String(o);console.error("Error initializing IndexedDB:",a),i({error:a})}),!0}else if(r.type==="getDevices"){const n=new h;return n.init().then(async()=>{try{const t=await n.getDevices();i(t)}catch(t){const e=t instanceof Error?t.message:String(t);console.error("Error fetching devices from IndexedDB:",e),i({error:e})}}).catch(t=>{const e=t instanceof Error?t.message:String(t);console.error("Error initializing IndexedDB:",e),i({error:e})}),!0}else if(r.type==="deleteHistory"){const{visitId:n}=r,t=new h;return t.init().then(async()=>{try{await t.deleteEntry(n),await f(!1),i({success:!0})}catch(e){const s=e instanceof Error?e.message:String(e);console.error("Error deleting history entry:",s),i({error:s})}}).catch(e=>{const s=e instanceof Error?e.message:String(e);console.error("Error initializing IndexedDB:",s),i({error:s})}),!0}else if(r.type==="pageContentExtracted"){const{url:n,content:t,summary:e}=r.data;if(n&&(t||e)){const s=new h;return s.init().then(async()=>{try{await s.updatePageContent(n,{content:t,summary:e}),console.debug("Updated page content for:",n),i({success:!0}),setTimeout(()=>f(!1),1e3)}catch(o){const a=o instanceof Error?o.message:String(o);console.error("Error updating page content:",a),i({error:a})}}).catch(o=>{const a=o instanceof Error?o.message:String(o);console.error("Error initializing IndexedDB:",a),i({error:a})}),!0}}else if(r.type==="searchHistory"){const{query:n}=r,t=new h;return t.init().then(async()=>{try{const s=(await t.searchContent(n)).map(o=>({visitId:o.entry.visitId,url:o.entry.url,title:o.entry.title,visitTime:o.entry.visitTime,matches:o.matches}));i({success:!0,results:s})}catch(e){const s=e instanceof Error?e.message:String(e);console.error("Error searching history:",s),i({error:s})}}).catch(e=>{const s=e instanceof Error?e.message:String(e);console.error("Error initializing IndexedDB:",s),i({error:s})}),!0}});
