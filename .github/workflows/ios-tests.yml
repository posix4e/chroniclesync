name: iOS Tests

on:
  push:
    branches: [main]
    paths:
      - 'extension/**'
  pull_request:
    branches: [main]
    paths:
      - 'extension/**'
  workflow_dispatch:

jobs:
  build-and-test-ios:
    name: Build and Test iOS
    runs-on: macos-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable
      
      - name: Install dependencies
        run: |
          cd extension
          npm ci
          npm run build
      
      - name: Build Safari extension
        run: |
          cd extension
          NODE_OPTIONS="--experimental-vm-modules --no-warnings" npm run build:extension
      
      - name: List available simulators
        run: |
          xcrun simctl list devices available

      - name: Setup environment
        run: |
          cd extension/ios-tests/ChronicleSync
          
          # Debug: List directory structure
          echo "=== Directory Structure ===" | tee -a setup_log.txt
          find . -type f | sort | tee -a setup_log.txt
          
          # Debug: Check Assets.xcassets
          echo "=== Assets.xcassets Content ===" | tee -a setup_log.txt
          find ./ChronicleSync/Assets.xcassets -type f | sort | tee -a setup_log.txt
          
          # Debug: Check Extension Resources
          echo "=== Extension Resources ===" | tee -a setup_log.txt
          find ./ChronicleSync\ Extension/Resources -type f | sort | tee -a setup_log.txt
          
          # Find available simulator
          echo "=== Available Simulators ===" | tee -a setup_log.txt
          xcrun simctl list devices available | tee -a setup_log.txt
          
          # Try to find iPhone 16 Pro simulator
          IPHONE_16_PRO=$(xcrun simctl list devices available -j | jq -r '.devices | to_entries[] | .value[] | select(.isAvailable == true and .name == "iPhone 16 Pro") | .udid' | head -n 1)
          
          if [ -n "$IPHONE_16_PRO" ]; then
            echo "Found iPhone 16 Pro simulator: $IPHONE_16_PRO" | tee -a setup_log.txt
            echo "SIMULATOR_ID=$IPHONE_16_PRO" >> $GITHUB_ENV
            echo "SIMULATOR_NAME=iPhone 16 Pro" >> $GITHUB_ENV
          else
            # Find any iPhone simulator
            IPHONE_SIM=$(xcrun simctl list devices available -j | jq -r '.devices | to_entries[] | .value[] | select(.isAvailable == true and (.name | contains("iPhone"))) | .udid' | head -n 1)
            
            if [ -n "$IPHONE_SIM" ]; then
              IPHONE_NAME=$(xcrun simctl list devices available -j | jq -r --arg UDID "$IPHONE_SIM" '.devices | to_entries[] | .value[] | select(.udid == $UDID) | .name' | head -n 1)
              echo "Found iPhone simulator: $IPHONE_SIM ($IPHONE_NAME)" | tee -a setup_log.txt
              echo "SIMULATOR_ID=$IPHONE_SIM" >> $GITHUB_ENV
              echo "SIMULATOR_NAME=$IPHONE_NAME" >> $GITHUB_ENV
            else
              # Find any simulator
              ANY_SIM=$(xcrun simctl list devices available -j | jq -r '.devices | to_entries[] | .value[] | select(.isAvailable == true) | .udid' | head -n 1)
              
              if [ -n "$ANY_SIM" ]; then
                ANY_NAME=$(xcrun simctl list devices available -j | jq -r --arg UDID "$ANY_SIM" '.devices | to_entries[] | .value[] | select(.udid == $UDID) | .name' | head -n 1)
                echo "Found simulator: $ANY_SIM ($ANY_NAME)" | tee -a setup_log.txt
                echo "SIMULATOR_ID=$ANY_SIM" >> $GITHUB_ENV
                echo "SIMULATOR_NAME=$ANY_NAME" >> $GITHUB_ENV
              else
                echo "No available simulator found, will use generic destination" | tee -a setup_log.txt
                echo "SIMULATOR_ID=generic" >> $GITHUB_ENV
                echo "SIMULATOR_NAME=generic" >> $GITHUB_ENV
              fi
            fi
          fi
      
      - name: Upload setup logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ios-setup-logs
          path: extension/ios-tests/ChronicleSync/setup_log.txt
          retention-days: 30
      
      - name: Build iOS app for simulator
        run: |
          cd extension/ios-tests/ChronicleSync
          
          echo "=== Building iOS app with simulator: $SIMULATOR_NAME ($SIMULATOR_ID) ===" | tee -a build_log.txt
          
          if [ "$SIMULATOR_ID" == "generic" ]; then
            xcodebuild build -scheme "ChronicleSync" -destination "platform=iOS Simulator,id=dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder" -verbose 2>&1 | tee -a build_log.txt
          else
            xcodebuild build -scheme "ChronicleSync" -destination "platform=iOS Simulator,id=$SIMULATOR_ID" -verbose 2>&1 | tee -a build_log.txt
          fi
          
          # Check if build was successful
          if [ $? -eq 0 ]; then
            echo "Build successful" | tee -a build_log.txt
            echo "BUILD_SUCCESS=true" >> $GITHUB_ENV
          else
            echo "Build failed" | tee -a build_log.txt
            echo "BUILD_SUCCESS=false" >> $GITHUB_ENV
          fi
      
      - name: Upload build logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ios-build-logs
          path: extension/ios-tests/ChronicleSync/build_log.txt
          retention-days: 30
          
      - name: Create archive and IPA
        if: env.BUILD_SUCCESS == 'true'
        continue-on-error: true
        # Future enhancement: Use Apple Developer credentials from GitHub secrets when available
        # Uncomment these lines when you have the secrets configured in your GitHub repository
        # env:
        #   APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        #   APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
        #   APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        #   APPLE_PROVISIONING_PROFILE_BASE64: ${{ secrets.APPLE_PROVISIONING_PROFILE_BASE64 }}
        #   APPLE_KEYCHAIN_PASSWORD: ${{ secrets.APPLE_KEYCHAIN_PASSWORD || 'github-actions' }}
        run: |
          cd extension/ios-tests/ChronicleSync
          
          # Create IPA directory
          mkdir -p "./IPA"
          
          # For now, we're always using self-signing
          # In the future, when Apple Developer credentials are available, uncomment the if-else block
          # and remove the echo lines below
          
          echo "=== Creating self-signed archive for iOS app ===" | tee -a archive_log.txt
          
          # The following block is for future use with Apple Developer credentials
          # Uncomment when you have the secrets configured in your GitHub repository
          
          # if [ -n "$APPLE_TEAM_ID" ] && [ -n "$APPLE_CERTIFICATE_BASE64" ]; then
          #   echo "=== Creating archive with Apple Developer credentials ===" | tee -a archive_log.txt
          #   
          #   # Create keychain
          #   KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          #   KEYCHAIN_PASSWORD="${APPLE_KEYCHAIN_PASSWORD}"
          #   
          #   # Create temporary keychain
          #   security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          #   security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          #   security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          #   
          #   # Add keychain to search list
          #   security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | sed s/\"//g)
          #   
          #   # Decode and import certificate
          #   echo "=== Importing certificate ===" | tee -a archive_log.txt
          #   CERTIFICATE_PATH="$RUNNER_TEMP/certificate.p12"
          #   echo -n "$APPLE_CERTIFICATE_BASE64" | base64 --decode > "$CERTIFICATE_PATH"
          #   security import "$CERTIFICATE_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          #   security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          #   
          #   # Get the identity from the keychain
          #   IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "1)" | awk -F '"' '{print $2}')
          #   echo "Using identity: $IDENTITY" | tee -a archive_log.txt
          #   
          #   # Import provisioning profile if available
          #   if [ -n "$APPLE_PROVISIONING_PROFILE_BASE64" ]; then
          #     echo "=== Importing provisioning profile ===" | tee -a archive_log.txt
          #     PROFILE_PATH="$RUNNER_TEMP/profile.mobileprovision"
          #     echo -n "$APPLE_PROVISIONING_PROFILE_BASE64" | base64 --decode > "$PROFILE_PATH"
          #     mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          #     PROFILE_UUID=$(grep -a -A 1 "UUID" "$PROFILE_PATH" | grep -o "[-A-Z0-9]\{36\}")
          #     cp "$PROFILE_PATH" ~/Library/MobileDevice/Provisioning\ Profiles/"$PROFILE_UUID".mobileprovision
          #     echo "Imported provisioning profile with UUID: $PROFILE_UUID" | tee -a archive_log.txt
          #   else
          #     echo "No provisioning profile provided, will use automatic signing" | tee -a archive_log.txt
          #   fi
          #   
          #   # Create export options plist
          #   cat > ExportOptions.plist << EOL
          #   <?xml version="1.0" encoding="UTF-8"?>
          #   <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          #   <plist version="1.0">
          #   <dict>
          #       <key>method</key>
          #       <string>development</string>
          #       <key>teamID</key>
          #       <string>$APPLE_TEAM_ID</string>
          #       <key>compileBitcode</key>
          #       <false/>
          #       <key>signingStyle</key>
          #       <string>automatic</string>
          #   </dict>
          #   </plist>
          #   EOL
          #   
          #   # Create a signing configuration for CI
          #   cat > ci_signing_config.xcconfig << EOL
          #   DEVELOPMENT_TEAM = $APPLE_TEAM_ID
          #   CODE_SIGN_IDENTITY = Apple Development
          #   CODE_SIGN_STYLE = Automatic
          #   EOL
          #   
          #   # Archive the app with Apple Developer signing
          #   echo "=== Building archive with Apple Developer signing ===" | tee -a archive_log.txt
          #   xcodebuild archive -scheme "ChronicleSync" -archivePath "./ChronicleSync.xcarchive" -xcconfig ci_signing_config.xcconfig -allowProvisioningUpdates -verbose 2>&1 | tee -a archive_log.txt
          #   ARCHIVE_EXIT_CODE=${PIPESTATUS[0]}
          #   
          # else
          #   echo "=== Creating self-signed archive for iOS app ===" | tee -a archive_log.txt
          #   echo "No Apple Developer credentials provided, using self-signing" | tee -a archive_log.txt
            
            # Create a self-signed certificate for code signing
            echo "=== Creating self-signed certificate ===" | tee -a archive_log.txt
            
            # Generate a private key
            openssl genrsa -out ChronicleSync.key 2048
            
            # Generate a certificate signing request
            openssl req -new -key ChronicleSync.key -out ChronicleSync.csr -subj "/CN=ChronicleSync/O=ChronicleSync/C=US"
            
            # Generate a self-signed certificate
            openssl x509 -req -days 365 -in ChronicleSync.csr -signkey ChronicleSync.key -out ChronicleSync.crt
            
            # Create a keychain for the certificate
            security create-keychain -p github-actions github-actions.keychain
            security default-keychain -s github-actions.keychain
            security unlock-keychain -p github-actions github-actions.keychain
            security set-keychain-settings -t 3600 -u github-actions.keychain
            
            # Import the certificate to the keychain
            security import ChronicleSync.crt -k github-actions.keychain -T /usr/bin/codesign
            security import ChronicleSync.key -k github-actions.keychain -T /usr/bin/codesign
            security set-key-partition-list -S apple-tool:,apple: -s -k github-actions github-actions.keychain
            
            # Get the identity from the keychain
            IDENTITY=$(security find-identity -v -p codesigning github-actions.keychain | grep "1)" | awk -F '"' '{print $2}')
            echo "Using identity: $IDENTITY" | tee -a archive_log.txt
            
            # Create a temporary export options plist
            cat > ExportOptions.plist << EOL
            <?xml version="1.0" encoding="UTF-8"?>
            <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
            <plist version="1.0">
            <dict>
                <key>method</key>
                <string>ad-hoc</string>
                <key>compileBitcode</key>
                <false/>
                <key>signingStyle</key>
                <string>manual</string>
                <key>signingCertificate</key>
                <string>$IDENTITY</string>
            </dict>
            </plist>
            EOL
            
            # Create a signing configuration for CI
            cat > ci_signing_config.xcconfig << EOL
            CODE_SIGN_IDENTITY = $IDENTITY
            CODE_SIGN_STYLE = Manual
            CODE_SIGNING_REQUIRED = NO
            CODE_SIGNING_ALLOWED = YES
            EOL
            
            # Modify project settings to allow building without a provisioning profile
            /usr/libexec/PlistBuddy -c "Set :objects:*:buildSettings:CODE_SIGNING_REQUIRED NO" ChronicleSync.xcodeproj/project.pbxproj || true
            /usr/libexec/PlistBuddy -c "Set :objects:*:buildSettings:CODE_SIGNING_ALLOWED YES" ChronicleSync.xcodeproj/project.pbxproj || true
            /usr/libexec/PlistBuddy -c "Set :objects:*:buildSettings:CODE_SIGN_IDENTITY -" ChronicleSync.xcodeproj/project.pbxproj || true
            
            # Archive the app with self-signing for CI
            echo "=== Building archive with self-signing ===" | tee -a archive_log.txt
            xcodebuild archive -scheme "ChronicleSync" -archivePath "./ChronicleSync.xcarchive" -xcconfig ci_signing_config.xcconfig -allowProvisioningUpdates -verbose 2>&1 | tee -a archive_log.txt
            ARCHIVE_EXIT_CODE=${PIPESTATUS[0]}
          fi
          
          # Check if archive was successful
          if [ $ARCHIVE_EXIT_CODE -eq 0 ] && [ -d "./ChronicleSync.xcarchive" ]; then
            echo "Archive successful" | tee -a archive_log.txt
            
            # Export the archive as an IPA
            echo "=== Exporting archive as IPA ===" | tee -a archive_log.txt
            xcodebuild -exportArchive -archivePath "./ChronicleSync.xcarchive" -exportOptionsPlist ExportOptions.plist -exportPath "./IPA" -verbose 2>&1 | tee -a archive_log.txt
            EXPORT_EXIT_CODE=${PIPESTATUS[0]}
            
            # Check if export was successful
            if [ $EXPORT_EXIT_CODE -eq 0 ] && [ -d "./IPA" ] && [ "$(ls -A ./IPA)" ]; then
              echo "Export successful" | tee -a archive_log.txt
              echo "ARCHIVE_SUCCESS=true" >> $GITHUB_ENV
              
              # Create a debug info file with useful information
              echo "# iOS Safari Extension Debug Information" > "./IPA/DEBUG_INFO.md"
              echo "" >> "./IPA/DEBUG_INFO.md"
              echo "## Build Information" >> "./IPA/DEBUG_INFO.md"
              echo "- Build Date: $(date)" >> "./IPA/DEBUG_INFO.md"
              echo "- Xcode Version: $(xcodebuild -version)" >> "./IPA/DEBUG_INFO.md"
              # For now, we're always using self-signing
              echo "- Self-signed Identity: $IDENTITY" >> "./IPA/DEBUG_INFO.md"
              echo "- Signing Method: Self-signed" >> "./IPA/DEBUG_INFO.md"
              
              # Uncomment when you have the secrets configured in your GitHub repository
              # if [ -n "$APPLE_TEAM_ID" ]; then
              #   echo "- Team ID: $APPLE_TEAM_ID" >> "./IPA/DEBUG_INFO.md"
              #   echo "- Signing Method: Apple Developer" >> "./IPA/DEBUG_INFO.md"
              # else
              #   echo "- Self-signed Identity: $IDENTITY" >> "./IPA/DEBUG_INFO.md"
              #   echo "- Signing Method: Self-signed" >> "./IPA/DEBUG_INFO.md"
              # fi
              echo "" >> "./IPA/DEBUG_INFO.md"
              echo "## IPA Contents" >> "./IPA/DEBUG_INFO.md"
              echo "\`\`\`" >> "./IPA/DEBUG_INFO.md"
              find "./IPA" -type f | sort >> "./IPA/DEBUG_INFO.md"
              echo "\`\`\`" >> "./IPA/DEBUG_INFO.md"
              
              # Add note about IPA
              echo "## Note" >> "./IPA/DEBUG_INFO.md"
              # For now, we're always using self-signing
              echo "This IPA is self-signed for debugging purposes only. It cannot be installed on physical devices without proper Apple Developer provisioning." >> "./IPA/DEBUG_INFO.md"
              
              # Uncomment when you have the secrets configured in your GitHub repository
              # if [ -n "$APPLE_TEAM_ID" ]; then
              #   echo "This IPA is signed with an Apple Developer certificate. It can be installed on registered test devices." >> "./IPA/DEBUG_INFO.md"
              # else
              #   echo "This IPA is self-signed for debugging purposes only. It cannot be installed on physical devices without proper Apple Developer provisioning." >> "./IPA/DEBUG_INFO.md"
              # fi
            else
              echo "Export failed" | tee -a archive_log.txt
              echo "ARCHIVE_SUCCESS=false" >> $GITHUB_ENV
              
              # Create a fallback IPA with extension files for debugging
              echo "=== Creating fallback IPA with extension files ===" | tee -a archive_log.txt
              
              # Create a placeholder file
              echo "This is a placeholder file. IPA creation failed, but extension files are included for debugging." > "./IPA/README.txt"
              
              # Create a debug info file with useful information
              echo "# iOS Safari Extension Debug Information" > "./IPA/DEBUG_INFO.md"
              echo "" >> "./IPA/DEBUG_INFO.md"
              echo "## Build Information" >> "./IPA/DEBUG_INFO.md"
              echo "- Build Date: $(date)" >> "./IPA/DEBUG_INFO.md"
              echo "- Xcode Version: $(xcodebuild -version)" >> "./IPA/DEBUG_INFO.md"
              # Uncomment when you have the secrets configured in your GitHub repository
              # if [ -n "$APPLE_TEAM_ID" ]; then
              #   echo "- Team ID: $APPLE_TEAM_ID" >> "./IPA/DEBUG_INFO.md"
              #   echo "- Signing Method: Apple Developer (failed)" >> "./IPA/DEBUG_INFO.md"
              # fi
              echo "" >> "./IPA/DEBUG_INFO.md"
              echo "## Extension Files" >> "./IPA/DEBUG_INFO.md"
              echo "\`\`\`" >> "./IPA/DEBUG_INFO.md"
              find "./ChronicleSync Extension" -type f | sort >> "./IPA/DEBUG_INFO.md"
              echo "\`\`\`" >> "./IPA/DEBUG_INFO.md"
              
              # Copy key extension files for debugging
              mkdir -p "./IPA/ExtensionFiles"
              cp -r "./ChronicleSync Extension/Resources" "./IPA/ExtensionFiles/"
              cp "./ChronicleSync Extension/"*.swift "./IPA/ExtensionFiles/"
              
              # Copy archive contents if available
              if [ -d "./ChronicleSync.xcarchive" ]; then
                mkdir -p "./IPA/ArchiveContents"
                cp -r "./ChronicleSync.xcarchive/Products" "./IPA/ArchiveContents/" || true
              fi
            fi
          else
            echo "Archive failed" | tee -a archive_log.txt
            echo "ARCHIVE_SUCCESS=false" >> $GITHUB_ENV
            
            # Create a fallback IPA with extension files for debugging
            echo "=== Creating fallback IPA with extension files ===" | tee -a archive_log.txt
            
            # Create a placeholder file
            echo "This is a placeholder file. Archive creation failed, but extension files are included for debugging." > "./IPA/README.txt"
            
            # Create a debug info file with useful information
            echo "# iOS Safari Extension Debug Information" > "./IPA/DEBUG_INFO.md"
            echo "" >> "./IPA/DEBUG_INFO.md"
            echo "## Build Information" >> "./IPA/DEBUG_INFO.md"
            echo "- Build Date: $(date)" >> "./IPA/DEBUG_INFO.md"
            echo "- Xcode Version: $(xcodebuild -version)" >> "./IPA/DEBUG_INFO.md"
            # Uncomment when you have the secrets configured in your GitHub repository
            # if [ -n "$APPLE_TEAM_ID" ]; then
            #   echo "- Team ID: $APPLE_TEAM_ID" >> "./IPA/DEBUG_INFO.md"
            #   echo "- Signing Method: Apple Developer (failed)" >> "./IPA/DEBUG_INFO.md"
            # fi
            echo "" >> "./IPA/DEBUG_INFO.md"
            echo "## Extension Files" >> "./IPA/DEBUG_INFO.md"
            echo "\`\`\`" >> "./IPA/DEBUG_INFO.md"
            find "./ChronicleSync Extension" -type f | sort >> "./IPA/DEBUG_INFO.md"
            echo "\`\`\`" >> "./IPA/DEBUG_INFO.md"
            
            # Copy key extension files for debugging
            mkdir -p "./IPA/ExtensionFiles"
            cp -r "./ChronicleSync Extension/Resources" "./IPA/ExtensionFiles/"
            cp "./ChronicleSync Extension/"*.swift "./IPA/ExtensionFiles/"
          fi
      
      - name: Upload archive logs
        uses: actions/upload-artifact@v4
        if: always() && env.BUILD_SUCCESS == 'true'
        with:
          name: ios-archive-logs
          path: extension/ios-tests/ChronicleSync/archive_log.txt
          retention-days: 30
          
      - name: Upload IPA
        uses: actions/upload-artifact@v4
        if: env.BUILD_SUCCESS == 'true' && env.ARCHIVE_SUCCESS == 'true'
        with:
          name: ios-ipa
          path: extension/ios-tests/ChronicleSync/IPA
          retention-days: 30
      
      - name: Test iOS app
        if: env.BUILD_SUCCESS == 'true'
        continue-on-error: true
        id: test_step
        timeout-minutes: 1
        run: |
          cd extension/ios-tests/ChronicleSync
          
          echo "=== Testing iOS app with simulator: $SIMULATOR_NAME ($SIMULATOR_ID) ===" | tee -a test_log.txt
          echo "=== Test timeout set to 1 minute ===" | tee -a test_log.txt
          
          # Create a variable to store the exit code
          TEST_EXIT_CODE=0
          
          # Run only the basic app launch test to verify functionality
          # This significantly reduces test time while ensuring basic functionality
          if [ "$SIMULATOR_ID" == "generic" ]; then
            echo "Running basic tests with generic simulator..." | tee -a test_log.txt
            xcodebuild test -scheme "ChronicleSync" -destination "platform=iOS Simulator,id=dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder" -only-testing:ChronicleSync_UITests/testAppLaunch -resultBundlePath TestResults.xcresult -verbose 2>&1 | tee -a test_log.txt
            TEST_EXIT_CODE=${PIPESTATUS[0]}
          else
            echo "Running basic tests with simulator ID: $SIMULATOR_ID..." | tee -a test_log.txt
            xcodebuild test -scheme "ChronicleSync" -destination "platform=iOS Simulator,id=$SIMULATOR_ID" -only-testing:ChronicleSync_UITests/testAppLaunch -resultBundlePath TestResults.xcresult -verbose 2>&1 | tee -a test_log.txt
            TEST_EXIT_CODE=${PIPESTATUS[0]}
          fi
          
          # Check if tests were successful
          if [ $TEST_EXIT_CODE -eq 0 ]; then
            echo "Tests successful" | tee -a test_log.txt
            echo "TESTS_SUCCESS=true" >> $GITHUB_ENV
            echo "test_result=success" >> $GITHUB_OUTPUT
          else
            echo "Tests failed with exit code $TEST_EXIT_CODE" | tee -a test_log.txt
            echo "TESTS_SUCCESS=false" >> $GITHUB_ENV
            echo "test_result=failure" >> $GITHUB_OUTPUT
            
            # Ensure TestResults.xcresult exists for artifact upload
            if [ ! -d "TestResults.xcresult" ]; then
              mkdir -p "TestResults.xcresult"
              echo "Test execution failed with exit code $TEST_EXIT_CODE" > "TestResults.xcresult/README.txt"
            fi
            
            # Don't fail the workflow, but mark this step as failed
            # This allows subsequent steps to run while still indicating the test failure
            exit 0
          fi
      
      - name: Upload test logs
        uses: actions/upload-artifact@v4
        if: always() && env.BUILD_SUCCESS == 'true'
        with:
          name: ios-test-logs
          path: extension/ios-tests/ChronicleSync/test_log.txt
          retention-days: 30
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always() && env.BUILD_SUCCESS == 'true'
        with:
          name: ios-test-results
          path: extension/ios-tests/ChronicleSync/TestResults.xcresult
          retention-days: 30
      
      - name: Extract screenshots
        if: always() && env.BUILD_SUCCESS == 'true'
        continue-on-error: true
        run: |
          cd extension/ios-tests/ChronicleSync
          mkdir -p screenshots
          
          # Check if TestResults.xcresult exists
          if [ -d "TestResults.xcresult" ]; then
            xcrun xcresulttool get --legacy --path TestResults.xcresult --format json | grep -o '"filename" : ".*\.png"' | awk -F'"' '{print $4}' | xargs -I{} find TestResults.xcresult -name {} -exec cp {} screenshots/ \; || true
            
            # Check if any screenshots were found
            if [ "$(ls -A screenshots)" ]; then
              echo "Screenshots extracted successfully"
            else
              echo "No screenshots found in test results"
              # Create a placeholder file to avoid artifact upload warning
              echo "No screenshots were captured during the test run." > screenshots/README.txt
            fi
          else
            echo "TestResults.xcresult directory not found, skipping screenshot extraction"
            # Create a placeholder file to avoid artifact upload warning
            echo "TestResults.xcresult directory not found. No screenshots available." > screenshots/README.txt
          fi
      
      - name: Upload screenshots
        uses: actions/upload-artifact@v4
        if: always() && env.BUILD_SUCCESS == 'true'
        with:
          name: ios-screenshots
          path: extension/ios-tests/ChronicleSync/screenshots
          retention-days: 30
          
      - name: Workflow Summary
        if: always()
        run: |
          echo "# iOS Build and Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Build summary
          if [ "$BUILD_SUCCESS" == "true" ]; then
            echo "✅ **Build:** Successful" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Build:** Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Archive summary
          if [ "$ARCHIVE_SUCCESS" == "true" ]; then
            echo "✅ **Archive:** Successful" >> $GITHUB_STEP_SUMMARY
          elif [ "$BUILD_SUCCESS" == "true" ]; then
            echo "⚠️ **Archive:** Failed (expected in CI without proper signing)" >> $GITHUB_STEP_SUMMARY
          else
            echo "⏭️ **Archive:** Skipped (build failed)" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Test summary
          if [ "$TESTS_SUCCESS" == "true" ]; then
            echo "✅ **Tests:** Successful" >> $GITHUB_STEP_SUMMARY
          elif [ "$BUILD_SUCCESS" == "true" ]; then
            echo "❌ **Tests:** Failed" >> $GITHUB_STEP_SUMMARY
          else
            echo "⏭️ **Tests:** Skipped (build failed)" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- Setup logs" >> $GITHUB_STEP_SUMMARY
          echo "- Build logs" >> $GITHUB_STEP_SUMMARY
          
          if [ "$BUILD_SUCCESS" == "true" ]; then
            echo "- Archive logs" >> $GITHUB_STEP_SUMMARY
            echo "- IPA (placeholder if signing failed)" >> $GITHUB_STEP_SUMMARY
            echo "- Test logs" >> $GITHUB_STEP_SUMMARY
            echo "- Test results" >> $GITHUB_STEP_SUMMARY
            echo "- Screenshots (if any were captured)" >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: Check Test Status
        if: always() && env.BUILD_SUCCESS == 'true'
        run: |
          if [ "$TESTS_SUCCESS" != "true" ]; then
            echo "::error::Tests failed or timed out. Check the test logs for details."
            exit 1
          fi