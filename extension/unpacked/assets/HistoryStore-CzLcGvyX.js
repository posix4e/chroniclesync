var h=Object.defineProperty;var E=(c,s,r)=>s in c?h(c,s,{enumerable:!0,configurable:!0,writable:!0,value:r}):c[s]=r;var l=(c,s,r)=>E(c,typeof s!="symbol"?s+"":s,r);class I{constructor(){l(this,"DB_NAME","chroniclesync");l(this,"HISTORY_STORE","history");l(this,"DEVICE_STORE","devices");l(this,"DB_VERSION",3);l(this,"db",null)}async init(){return new Promise((s,r)=>{console.log("Initializing IndexedDB...");const n=indexedDB.open(this.DB_NAME,this.DB_VERSION);n.onerror=()=>{console.error("Error opening IndexedDB:",n.error),r(n.error)},n.onsuccess=()=>{console.log("IndexedDB opened successfully"),this.db=n.result,s()},n.onupgradeneeded=a=>{console.log("Upgrading IndexedDB schema...");const o=a.target.result;if(!o.objectStoreNames.contains(this.HISTORY_STORE)){const t=o.createObjectStore(this.HISTORY_STORE,{keyPath:"visitId"});t.createIndex("visitTime","visitTime"),t.createIndex("syncStatus","syncStatus"),t.createIndex("url","url"),t.createIndex("deviceId","deviceId"),t.createIndex("lastModified","lastModified"),t.createIndex("summaryStatus","summaryStatus"),console.log("Created history store with indexes")}o.objectStoreNames.contains(this.DEVICE_STORE)||(o.createObjectStore(this.DEVICE_STORE,{keyPath:"deviceId"}).createIndex("lastSeen","lastSeen"),console.log("Created devices store"))}})}async addEntry(s){if(!this.db)throw new Error("Database not initialized");return new Promise((r,n)=>{const o=this.db.transaction([this.HISTORY_STORE],"readwrite").objectStore(this.HISTORY_STORE),t={...s,syncStatus:"pending",lastModified:Date.now()},e=o.put(t);e.onerror=()=>n(e.error),e.onsuccess=()=>r()})}async getUnsyncedEntries(){if(!this.db)throw new Error("Database not initialized");return new Promise((s,r)=>{const t=this.db.transaction([this.HISTORY_STORE],"readonly").objectStore(this.HISTORY_STORE).index("syncStatus").getAll("pending");t.onerror=()=>r(t.error),t.onsuccess=()=>s(t.result)})}async markAsSynced(s){if(!this.db)throw new Error("Database not initialized");return new Promise((r,n)=>{const o=this.db.transaction([this.HISTORY_STORE],"readwrite").objectStore(this.HISTORY_STORE),t=o.get(s);t.onerror=()=>n(t.error),t.onsuccess=()=>{const e=t.result;if(e){e.syncStatus="synced",e.lastModified=Date.now();const i=o.put(e);i.onerror=()=>n(i.error),i.onsuccess=()=>r()}else r()}})}async getEntries(s,r){if(!this.db)throw console.error("Database not initialized"),new Error("Database not initialized");return new Promise((n,a)=>{console.log("Getting history entries...");const t=this.db.transaction([this.HISTORY_STORE],"readonly").objectStore(this.HISTORY_STORE);let e;s?e=t.index("deviceId").getAll(s):e=t.index("lastModified").getAll(r?IDBKeyRange.lowerBound(r):void 0),e.onerror=()=>{console.error("Error getting entries:",e.error),a(e.error)},e.onsuccess=()=>{const d=(e.result||[]).filter(u=>!u.deleted);console.log("Retrieved entries:",d.length),n(d)}})}async mergeRemoteEntries(s){if(!this.db)throw new Error("Database not initialized");return new Promise((r,n)=>{const o=this.db.transaction([this.HISTORY_STORE],"readwrite").objectStore(this.HISTORY_STORE);let t=0,e=0;s.forEach(i=>{const d=o.get(i.visitId);d.onerror=()=>{e++,t+e===s.length&&(e>0?n(new Error(`Failed to merge ${e} entries`)):r())},d.onsuccess=()=>{const u=d.result;if(!u||i.lastModified>u.lastModified){const S=o.put({...i,syncStatus:"synced"});S.onerror=()=>{e++,t+e===s.length&&(e>0?n(new Error(`Failed to merge ${e} entries`)):r())},S.onsuccess=()=>{t++,t+e===s.length&&(e>0?n(new Error(`Failed to merge ${e} entries`)):r())}}else t++,t+e===s.length&&(e>0?n(new Error(`Failed to merge ${e} entries`)):r())}})})}async updateDevice(s){if(!this.db)throw new Error("Database not initialized");return new Promise((r,n)=>{const o=this.db.transaction([this.DEVICE_STORE],"readwrite").objectStore(this.DEVICE_STORE),t={...s,lastSeen:Date.now()},e=o.put(t);e.onerror=()=>n(e.error),e.onsuccess=()=>r()})}async getDevices(){if(!this.db)throw new Error("Database not initialized");return new Promise((s,r)=>{const o=this.db.transaction([this.DEVICE_STORE],"readonly").objectStore(this.DEVICE_STORE).getAll();o.onerror=()=>r(o.error),o.onsuccess=()=>s(o.result||[])})}async deleteEntry(s){if(!this.db)throw new Error("Database not initialized");return new Promise((r,n)=>{const o=this.db.transaction([this.HISTORY_STORE],"readwrite").objectStore(this.HISTORY_STORE),t=o.get(s);t.onerror=()=>n(t.error),t.onsuccess=()=>{const e=t.result;if(e){e.deleted=!0,e.lastModified=Date.now(),e.syncStatus="pending";const i=o.put(e);i.onerror=()=>n(i.error),i.onsuccess=()=>r()}else r()}})}async updateEntry(s){if(!this.db)throw new Error("Database not initialized");return new Promise((r,n)=>{const o=this.db.transaction([this.HISTORY_STORE],"readwrite").objectStore(this.HISTORY_STORE),t={...s,lastModified:Date.now(),syncStatus:"pending"},e=o.put(t);e.onerror=()=>n(e.error),e.onsuccess=()=>r()})}}export{I as H};
