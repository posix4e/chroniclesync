import{H as f}from"./assets/HistoryStore-D4jEreiL.js";const E={apiEndpoint:"https://api.chroniclesync.xyz",pagesUrl:"https://chroniclesync.pages.dev",clientId:"extension-default"},C="https://api-staging.chroniclesync.xyz";async function v(){try{const t=await chrome.storage.sync.get(["apiEndpoint","pagesUrl","clientId","environment","customApiUrl"]);let o=E.apiEndpoint;return t.environment==="staging"?o=C:t.environment==="custom"&&t.customApiUrl&&(o=t.customApiUrl),{apiEndpoint:o,pagesUrl:t.pagesUrl||E.pagesUrl,clientId:t.clientId||E.clientId}}catch(t){return console.error("Error loading config:",t),E}}async function U(){const t=await chrome.storage.local.get(["deviceId"]);if(t.deviceId)return t.deviceId;const o="device_"+Math.random().toString(36).substring(2);return await chrome.storage.local.set({deviceId:o}),o}async function B(){var r;const t=navigator.platform,o=navigator.userAgent,n=await U(),i="Chrome",e=((r=/Chrome\/([0-9.]+)/.exec(o))==null?void 0:r[1])||"unknown";return{deviceId:n,platform:t,userAgent:o,browserName:i,browserVersion:e}}function S(){var t,o,n,i;return typeof chrome<"u"&&chrome.runtime&&chrome.runtime.id?"chrome":typeof window<"u"&&"browser"in window&&typeof((o=(t=window.browser)==null?void 0:t.runtime)==null?void 0:o.id)<"u"?typeof((i=(n=window.browser)==null?void 0:n.runtime)==null?void 0:i.getBrowserInfo)=="function"?"firefox":"safari":"unknown"}function h(){return typeof window<"u"&&!("browser"in window)?chrome:window.browser}const w={local:{get:async t=>{const o=h();return S()==="chrome"?new Promise(n=>{o.storage.local.get(t,i=>n(i))}):o.storage.local.get(t)},set:async t=>{const o=h();return S()==="chrome"?new Promise(n=>{o.storage.local.set(t,()=>n())}):o.storage.local.set(t)}}},x={sendMessage:async t=>{const o=h();return S()==="chrome"?new Promise((n,i)=>{o.runtime.sendMessage(t,e=>{o.runtime.lastError?i(o.runtime.lastError):n(e)})}):o.runtime.sendMessage(t)}},H=5*60*1e3;async function M(){try{return await w.local.get(["initialized"]),await v(),await w.local.set({initialized:!0}),!0}catch(t){return console.error("Failed to initialize extension:",t),!1}}async function m(t=!1){var o,n;try{if(!(await w.local.get(["initialized"])).initialized&&!await M()){console.debug("Sync skipped: Extension not initialized");return}const e=await v();if(!e.clientId||e.clientId==="extension-default")throw console.debug("Sync paused: No client ID configured"),new Error("Please configure your Client ID in the extension popup");console.debug("Starting sync with client ID:",e.clientId);const r=await B(),c=Date.now(),a=(await w.local.get(["lastSync"])).lastSync||0,b=t?0:a,u=new f;await u.init(),await u.updateDevice(r);const D=h(),P=await new Promise(l=>{D.history.search({text:"",startTime:b,endTime:c,maxResults:1e4},l)}),T=(await Promise.all(P.map(async l=>l.url?(await new Promise(g=>{D.history.getVisits({url:l.url},g)})).filter(g=>{const y=g.visitTime||0;return y>=b&&y<=c}).map(g=>{var y;return{url:l.url,title:l.title||"",visitTime:g.visitTime||Date.now(),visitId:g.visitId.toString(),referringVisitId:((y=g.referringVisitId)==null?void 0:y.toString())||"0",transition:g.transition||"link",...r}}):[]))).flat();for(const l of T)await u.addEntry(l);const p=await u.getUnsyncedEntries();if(p.length>0){const l=await fetch(`${e.apiEndpoint}?clientId=${encodeURIComponent(e.clientId)}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({history:p,deviceInfo:r,lastSync:a})});if(!l.ok)throw new Error(`HTTP error! status: ${l.status}`);const d=await l.json();if(d.history&&d.history.length>0&&await u.mergeRemoteEntries(d.history),d.devices)for(const I of d.devices)await u.updateDevice(I);for(const I of p)await u.markAsSynced(I.visitId);const g=d.lastSyncTime||c,y=new Date(g).toLocaleString();await w.local.set({lastSync:g});const A=h();await new Promise(I=>{A.storage.sync.set({lastSync:y},()=>I())});try{x.sendMessage({type:"syncComplete",stats:{sent:p.length,received:((o=d.history)==null?void 0:o.length)||0,devices:((n=d.devices)==null?void 0:n.length)||0}}).catch(()=>{})}catch{}}console.debug("Successfully completed sync")}catch(i){console.error("Error syncing history:",i);try{const e=i instanceof Error?i.message:String(i);x.sendMessage({type:"syncError",error:e}).catch(()=>{})}catch{}}}m(!0);setInterval(()=>m(!1),H);const z=h();z.tabs.onUpdated.addListener(async(t,o,n)=>{o.url&&(console.debug(`Navigation to: ${o.url}`),setTimeout(()=>m(!1),1e3))});z.runtime.onMessage.addListener((t,o,n)=>{if(t.type==="getClientId")return w.local.get(["initialized"]).then(async i=>{if(!i.initialized&&!await M()){n({error:"Extension not initialized"});return}try{const e=await v();n({clientId:e.clientId==="extension-default"?null:e.clientId})}catch(e){const r=e instanceof Error?e.message:String(e);console.error("Error getting client ID:",r),n({error:"Failed to get client ID"})}}),!0;if(t.type==="triggerSync")return m(!0).then(()=>{n({success:!0,message:"Sync successful"})}).catch(i=>{const e=i instanceof Error?i.message:String(i);console.error("Manual sync failed:",e),n({error:e})}),!0;if(t.type==="getHistory"){const{deviceId:i,since:e,limit:r}=t,c=new f;return c.init().then(async()=>{try{const s=await c.getEntries(i,e),a=r?s.slice(0,r):s;n(a)}catch(s){const a=s instanceof Error?s.message:String(s);console.error("Error fetching history from IndexedDB:",a),n({error:a})}}).catch(s=>{const a=s instanceof Error?s.message:String(s);console.error("Error initializing IndexedDB:",a),n({error:a})}),!0}else if(t.type==="getDevices"){const i=new f;return i.init().then(async()=>{try{const e=await i.getDevices();n(e)}catch(e){const r=e instanceof Error?e.message:String(e);console.error("Error fetching devices from IndexedDB:",r),n({error:r})}}).catch(e=>{const r=e instanceof Error?e.message:String(e);console.error("Error initializing IndexedDB:",r),n({error:r})}),!0}else if(t.type==="deleteHistory"){const{visitId:i}=t,e=new f;return e.init().then(async()=>{try{await e.deleteEntry(i),await m(!1),n({success:!0})}catch(r){const c=r instanceof Error?r.message:String(r);console.error("Error deleting history entry:",c),n({error:c})}}).catch(r=>{const c=r instanceof Error?r.message:String(r);console.error("Error initializing IndexedDB:",c),n({error:c})}),!0}else if(t.type==="pageContentExtracted"){const{url:i,content:e,summary:r}=t.data;if(i&&(e||r)){const c=new f;return c.init().then(async()=>{try{await c.updatePageContent(i,{content:e,summary:r}),console.debug("Updated page content for:",i),n({success:!0}),setTimeout(()=>m(!1),1e3)}catch(s){const a=s instanceof Error?s.message:String(s);console.error("Error updating page content:",a),n({error:a})}}).catch(s=>{const a=s instanceof Error?s.message:String(s);console.error("Error initializing IndexedDB:",a),n({error:a})}),!0}}else if(t.type==="searchHistory"){const{query:i}=t,e=new f;return e.init().then(async()=>{try{const c=(await e.searchContent(i)).map(s=>({visitId:s.entry.visitId,url:s.entry.url,title:s.entry.title,visitTime:s.entry.visitTime,matches:s.matches}));n({success:!0,results:c})}catch(r){const c=r instanceof Error?r.message:String(r);console.error("Error searching history:",c),n({error:c})}}).catch(r=>{const c=r instanceof Error?r.message:String(r);console.error("Error initializing IndexedDB:",c),n({error:c})}),!0}});
