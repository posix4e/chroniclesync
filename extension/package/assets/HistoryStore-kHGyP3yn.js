var R=Object.defineProperty;var I=(u,s,r)=>s in u?R(u,s,{enumerable:!0,configurable:!0,writable:!0,value:r}):u[s]=r;var S=(u,s,r)=>I(u,typeof s!="symbol"?s+"":s,r);class w{constructor(){S(this,"DB_NAME","chroniclesync");S(this,"HISTORY_STORE","history");S(this,"DEVICE_STORE","devices");S(this,"DB_VERSION",3);S(this,"db",null)}async init(){return new Promise((s,r)=>{console.log("Initializing IndexedDB...");const n=indexedDB.open(this.DB_NAME,this.DB_VERSION);n.onerror=()=>{console.error("Error opening IndexedDB:",n.error),r(n.error)},n.onsuccess=()=>{console.log("IndexedDB opened successfully"),this.db=n.result,s()},n.onupgradeneeded=a=>{console.log("Upgrading IndexedDB schema...");const o=a.target.result,t=a.oldVersion;if(!o.objectStoreNames.contains(this.HISTORY_STORE)){const e=o.createObjectStore(this.HISTORY_STORE,{keyPath:"visitId"});e.createIndex("visitTime","visitTime"),e.createIndex("syncStatus","syncStatus"),e.createIndex("url","url"),e.createIndex("deviceId","deviceId"),e.createIndex("lastModified","lastModified"),e.createIndex("summary","summary"),console.log("Created history store with indexes")}if(o.objectStoreNames.contains(this.DEVICE_STORE)||(o.createObjectStore(this.DEVICE_STORE,{keyPath:"deviceId"}).createIndex("lastSeen","lastSeen"),console.log("Created devices store")),t<3&&o.objectStoreNames.contains(this.HISTORY_STORE)){const e=n.transaction.objectStore(this.HISTORY_STORE);e.indexNames.contains("summary")||(e.createIndex("summary","summary"),console.log("Added summary index to history store"))}}})}async addEntry(s){if(!this.db)throw new Error("Database not initialized");return new Promise((r,n)=>{const o=this.db.transaction([this.HISTORY_STORE],"readwrite").objectStore(this.HISTORY_STORE),t={...s,syncStatus:"pending",lastModified:Date.now()},e=o.put(t);e.onerror=()=>n(e.error),e.onsuccess=()=>r()})}async getUnsyncedEntries(){if(!this.db)throw new Error("Database not initialized");return new Promise((s,r)=>{const t=this.db.transaction([this.HISTORY_STORE],"readonly").objectStore(this.HISTORY_STORE).index("syncStatus").getAll("pending");t.onerror=()=>r(t.error),t.onsuccess=()=>s(t.result)})}async markAsSynced(s){if(!this.db)throw new Error("Database not initialized");return new Promise((r,n)=>{const o=this.db.transaction([this.HISTORY_STORE],"readwrite").objectStore(this.HISTORY_STORE),t=o.get(s);t.onerror=()=>n(t.error),t.onsuccess=()=>{const e=t.result;if(e){e.syncStatus="synced",e.lastModified=Date.now();const i=o.put(e);i.onerror=()=>n(i.error),i.onsuccess=()=>r()}else r()}})}async getEntries(s,r){if(!this.db)throw console.error("Database not initialized"),new Error("Database not initialized");return new Promise((n,a)=>{console.log("Getting history entries...");const t=this.db.transaction([this.HISTORY_STORE],"readonly").objectStore(this.HISTORY_STORE);let e;s?e=t.index("deviceId").getAll(s):e=t.index("lastModified").getAll(r?IDBKeyRange.lowerBound(r):void 0),e.onerror=()=>{console.error("Error getting entries:",e.error),a(e.error)},e.onsuccess=()=>{const c=(e.result||[]).filter(l=>!l.deleted);console.log("Retrieved entries:",c.length),n(c)}})}async mergeRemoteEntries(s){if(!this.db)throw new Error("Database not initialized");return new Promise((r,n)=>{const o=this.db.transaction([this.HISTORY_STORE],"readwrite").objectStore(this.HISTORY_STORE);let t=0,e=0;s.forEach(i=>{const c=o.get(i.visitId);c.onerror=()=>{e++,t+e===s.length&&(e>0?n(new Error(`Failed to merge ${e} entries`)):r())},c.onsuccess=()=>{const l=c.result;if(!l||i.lastModified>l.lastModified){const d=o.put({...i,syncStatus:"synced"});d.onerror=()=>{e++,t+e===s.length&&(e>0?n(new Error(`Failed to merge ${e} entries`)):r())},d.onsuccess=()=>{t++,t+e===s.length&&(e>0?n(new Error(`Failed to merge ${e} entries`)):r())}}else t++,t+e===s.length&&(e>0?n(new Error(`Failed to merge ${e} entries`)):r())}})})}async updateDevice(s){if(!this.db)throw new Error("Database not initialized");return new Promise((r,n)=>{const o=this.db.transaction([this.DEVICE_STORE],"readwrite").objectStore(this.DEVICE_STORE),t={...s,lastSeen:Date.now()},e=o.put(t);e.onerror=()=>n(e.error),e.onsuccess=()=>r()})}async getDevices(){if(!this.db)throw new Error("Database not initialized");return new Promise((s,r)=>{const o=this.db.transaction([this.DEVICE_STORE],"readonly").objectStore(this.DEVICE_STORE).getAll();o.onerror=()=>r(o.error),o.onsuccess=()=>s(o.result||[])})}async updateEntrySummary(s,r){if(!this.db)throw new Error("Database not initialized");return new Promise((n,a)=>{const t=this.db.transaction([this.HISTORY_STORE],"readwrite").objectStore(this.HISTORY_STORE),i=t.index("url").getAll(s);i.onerror=()=>a(i.error),i.onsuccess=()=>{const c=i.result;if(c&&c.length>0){let l=0,d=0;c.forEach(h=>{h.summary={...r,version:1,lastModified:Date.now()},h.syncStatus="pending",h.lastModified=Date.now();const E=t.put(h);E.onerror=()=>{d++,l+d===c.length&&(d>0?a(new Error(`Failed to update ${d} entries`)):n())},E.onsuccess=()=>{l++,l+d===c.length&&(d>0?a(new Error(`Failed to update ${d} entries`)):n())}})}else n()}})}async deleteEntry(s){if(!this.db)throw new Error("Database not initialized");return new Promise((r,n)=>{const o=this.db.transaction([this.HISTORY_STORE],"readwrite").objectStore(this.HISTORY_STORE),t=o.get(s);t.onerror=()=>n(t.error),t.onsuccess=()=>{const e=t.result;if(e){e.deleted=!0,e.lastModified=Date.now(),e.syncStatus="pending";const i=o.put(e);i.onerror=()=>n(i.error),i.onsuccess=()=>r()}else r()}})}}export{w as H};
